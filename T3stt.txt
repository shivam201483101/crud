package com.sbi.yono.common.utility;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentMatchers;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.jdbc.core.ConnectionCallback;
import org.springframework.jdbc.core.JdbcTemplate;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.sql.PreparedStatement;
import java.sql.DatabaseMetaData;
import java.sql.SQLWarning;
import java.sql.Savepoint;
import java.sql.Clob;
import java.sql.Blob;
import java.sql.NClob;
import java.sql.SQLXML;
import java.sql.Array;
import java.sql.Struct;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Test DeleteUtility using Mockito for JdbcTemplate only.
 * We provide lightweight fake Connection/CallableStatement implementations
 * so Mockito does not mock JDBC classes (avoids MockMaker plugin issues).
 */
@ExtendWith(MockitoExtension.class)
class DeleteUtilityMockitoSafeTest {

    @Mock
    private JdbcTemplate jdbcTemplate;

    private DeleteUtility deleteUtility;
    private TestFlags flags;

    @BeforeEach
    void setUp() {
        flags = new TestFlags();

        // Initialize DeleteUtility with mocked JdbcTemplate
        deleteUtility = new DeleteUtility(jdbcTemplate);
    }

    @Test
    void testDeleteFunction_returnsSuccess_andCallsStoredProc() throws Exception {
        String leadId = "SBIY2NCA252171208650ZNAwBEqX"; // example 28+ char id

        // Make the mocked jdbcTemplate.execute(...) invoke the ConnectionCallback with our FakeConnection
        when(jdbcTemplate.execute(ArgumentMatchers.<ConnectionCallback<?>>any())).thenAnswer(invocation -> {
            ConnectionCallback<?> callback = invocation.getArgument(0);
            // call the callback with our fake connection which records actions in flags
            return callback.doInConnection(new FakeConnection(flags));
        });

        // Call the method under test
        String result = deleteUtility.deleteFunction(leadId);

        // Assert return value
        assertEquals(Constant.SUCCESS.getValue(), result);

        // Assert side-effects recorded by the fakes
        assertTrue(flags.prepareCallInvoked, "prepareCall should have been invoked");
        assertTrue(flags.setStringInvoked, "setString should have been invoked");
        assertTrue(flags.executeInvoked, "execute should have been invoked");
        assertTrue(flags.closeInvoked, "close should have been invoked");
        assertEquals(leadId, flags.lastSetStringValue, "parameter passed to CallableStatement should match");
    }

    // Container for recording actions performed by fakes
    static class TestFlags {
        volatile boolean prepareCallInvoked = false;
        volatile boolean setStringInvoked = false;
        volatile boolean executeInvoked = false;
        volatile boolean closeInvoked = false;
        volatile String lastSetStringValue = null;
    }

    // FakeConnection implements only prepareCall used by production code.
    static class FakeConnection implements Connection {
        private final TestFlags flags;
        FakeConnection(TestFlags flags) { this.flags = flags; }

        @Override
        public CallableStatement prepareCall(String sql) {
            flags.prepareCallInvoked = true;
            return new FakeCallableStatement(flags, sql);
        }

        // --- The rest of Connection methods are unused in our code under test ---
        // Implement them to throw UnsupportedOperationException or return simple defaults.

        @Override public Statement createStatement() { throw new UnsupportedOperationException(); }
        @Override public PreparedStatement prepareStatement(String sql) { throw new UnsupportedOperationException(); }
        @Override public String nativeSQL(String sql) { throw new UnsupportedOperationException(); }
        @Override public void setAutoCommit(boolean autoCommit) { throw new UnsupportedOperationException(); }
        @Override public boolean getAutoCommit() { throw new UnsupportedOperationException(); }
        @Override public void commit() { throw new UnsupportedOperationException(); }
        @Override public void rollback() { throw new UnsupportedOperationException(); }
        @Override public void close() { /* no-op */ }
        @Override public boolean isClosed() { return false; }
        @Override public DatabaseMetaData getMetaData() { throw new UnsupportedOperationException(); }
        @Override public void setReadOnly(boolean readOnly) { throw new UnsupportedOperationException(); }
        @Override public boolean isReadOnly() { throw new UnsupportedOperationException(); }
        @Override public void setCatalog(String catalog) { throw new UnsupportedOperationException(); }
        @Override public String getCatalog() { throw new UnsupportedOperationException(); }
        @Override public void setTransactionIsolation(int level) { throw new UnsupportedOperationException(); }
        @Override public int getTransactionIsolation() { throw new UnsupportedOperationException(); }
        @Override public SQLWarning getWarnings() { throw new UnsupportedOperationException(); }
        @Override public void clearWarnings() { throw new UnsupportedOperationException(); }
        @Override public Statement createStatement(int resultSetType, int resultSetConcurrency) { throw new UnsupportedOperationException(); }
        @Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) { throw new UnsupportedOperationException(); }
        @Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) { throw new UnsupportedOperationException(); }
        @Override public Map<String, Class<?>> getTypeMap() { throw new UnsupportedOperationException(); }
        @Override public void setTypeMap(Map<String, Class<?>> map) { throw new UnsupportedOperationException(); }
        @Override public void setHoldability(int holdability) { throw new UnsupportedOperationException(); }
        @Override public int getHoldability() { throw new UnsupportedOperationException(); }
        @Override public Savepoint setSavepoint() { throw new UnsupportedOperationException(); }
        @Override public Savepoint setSavepoint(String name) { throw new UnsupportedOperationException(); }
        @Override public void rollback(Savepoint savepoint) { throw new UnsupportedOperationException(); }
        @Override public void releaseSavepoint(Savepoint savepoint) { throw new UnsupportedOperationException(); }
        @Override public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) { throw new UnsupportedOperationException(); }
        @Override public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) { throw new UnsupportedOperationException(); }
        @Override public PreparedStatement prepareStatement(String sql, int[] columnIndexes) { throw new UnsupportedOperationException(); }
        @Override public PreparedStatement prepareStatement(String sql, String[] columnNames) { throw new UnsupportedOperationException(); }
        @Override public Clob createClob() { throw new UnsupportedOperationException(); }
        @Override public Blob createBlob() { throw new UnsupportedOperationException(); }
        @Override public NClob createNClob() { throw new UnsupportedOperationException(); }
        @Override public SQLXML createSQLXML() { throw new UnsupportedOperationException(); }
        @Override public boolean isValid(int timeout) { throw new UnsupportedOperationException(); }
        @Override public void setClientInfo(String name, String value) { throw new UnsupportedOperationException(); }
        @Override public void setClientInfo(Properties properties) { throw new UnsupportedOperationException(); }
        @Override public String getClientInfo(String name) { throw new UnsupportedOperationException(); }
        @Override public Properties getClientInfo() { throw new UnsupportedOperationException(); }
        @Override public Array createArrayOf(String typeName, Object[] elements) { throw new UnsupportedOperationException(); }
        @Override public Struct createStruct(String typeName, Object[] attributes) { throw new UnsupportedOperationException(); }
        @Override public void setSchema(String schema) { throw new UnsupportedOperationException(); }
        @Override public String getSchema() { throw new UnsupportedOperationException(); }
        @Override public void abort(Executor executor) { throw new UnsupportedOperationException(); }
        @Override public void setNetworkTimeout(Executor executor, int milliseconds) { throw new UnsupportedOperationException(); }
        @Override public int getNetworkTimeout() { throw new UnsupportedOperationException(); }
        @Override public <T> T unwrap(Class<T> iface) { throw new UnsupportedOperationException(); }
        @Override public boolean isWrapperFor(Class<?> iface) { throw new UnsupportedOperationException(); }
    }

    // FakeCallableStatement implements only the methods used in the production code
    static class FakeCallableStatement implements CallableStatement {
        private final TestFlags flags;
        private final String sql;

        FakeCallableStatement(TestFlags flags, String sql) {
            this.flags = flags;
            this.sql = sql;
        }

        @Override
        public void setString(int parameterIndex, String x) {
            flags.setStringInvoked = true;
            flags.lastSetStringValue = x;
        }

        @Override
        public boolean execute() {
            flags.executeInvoked = true;
            return true;
        }

        @Override
        public void close() {
            flags.closeInvoked = true;
        }

        // --- Remaining CallableStatement methods are not used; implement as unsupported ---
        @Override public ResultSet executeQuery() { throw new UnsupportedOperationException(); }
        @Override public int executeUpdate() { throw new UnsupportedOperationException(); }
        @Override public void setNull(int parameterIndex, int sqlType) { throw new UnsupportedOperationException(); }
        @Override public void setBoolean(int parameterIndex, boolean x) { throw new UnsupportedOperationException(); }
        @Override public void setByte(int parameterIndex, byte x) { throw new UnsupportedOperationException(); }
        @Override public void setShort(int parameterIndex, short x) { throw new UnsupportedOperationException(); }
        @Override public void setInt(int parameterIndex, int x) { throw new UnsupportedOperationException(); }
        @Override public void setLong(int parameterIndex, long x) { throw new UnsupportedOperationException(); }
        @Override public void setFloat(int parameterIndex, float x) { throw new UnsupportedOperationException(); }
        @Override public void setDouble(int parameterIndex, double x) { throw new UnsupportedOperationException(); }
        @Override public void setBigDecimal(int parameterIndex, java.math.BigDecimal x) { throw new UnsupportedOperationException(); }
        @Override public void setBytes(int parameterIndex, byte[] x) { throw new UnsupportedOperationException(); }
        @Override public void setDate(int parameterIndex, java.sql.Date x) { throw new UnsupportedOperationException(); }
        @Override public void setTime(int parameterIndex, java.sql.Time x) { throw new UnsupportedOperationException(); }
        @Override public void setTimestamp(int parameterIndex, java.sql.Timestamp x) { throw new UnsupportedOperationException(); }
        @Override public void setAsciiStream(int parameterIndex, java.io.InputStream x, int length) { throw new UnsupportedOperationException(); }
        @Override public void setBinaryStream(int parameterIndex, java.io.InputStream x, int length) { throw new UnsupportedOperationException(); }
        @Override public void clearParameters() { throw new UnsupportedOperationException(); }
        @Override public void setObject(int parameterIndex, Object x, int targetSqlType) { throw new UnsupportedOperationException(); }
        @Override public void setObject(int parameterIndex, Object x) { throw new UnsupportedOperationException(); }
        @Override public boolean execute(String sql) { throw new UnsupportedOperationException(); }
        @Override public ResultSet getResultSet() { throw new UnsupportedOperationException(); }
        @Override public int getUpdateCount() { throw new UnsupportedOperationException(); }
        @Override public boolean getMoreResults() { throw new UnsupportedOperationException(); }
        @Override public void setFetchDirection(int direction) { throw new UnsupportedOperationException(); }
        @Override public int getFetchDirection() { throw new UnsupportedOperationException(); }
        @Override public void setFetchSize(int rows) { throw new UnsupportedOperationException(); }
        @Override public int getFetchSize() { throw new UnsupportedOperationException(); }
        @Override public int getResultSetConcurrency() { throw new UnsupportedOperationException(); }
        @Override public int getResultSetType() { throw new UnsupportedOperationException(); }
        @Override public void addBatch(String sql) { throw new UnsupportedOperationException(); }
        @Override public void clearBatch() { throw new UnsupportedOperationException(); }
        @Override public int[] executeBatch() { throw new UnsupportedOperationException(); }
        @Override public Connection getConnection() { throw new UnsupportedOperationException(); }
        @Override public boolean getMoreResults(int current) { throw new UnsupportedOperationException(); }
        @Override public ResultSet getGeneratedKeys() { throw new UnsupportedOperationException(); }
        @Override public int executeUpdate(String sql, int autoGeneratedKeys) { throw new UnsupportedOperationException(); }
        @Override public int executeUpdate(String sql, int[] columnIndexes) { throw new UnsupportedOperationException(); }
        @Override public int executeUpdate(String sql, String[] columnNames) { throw new UnsupportedOperationException(); }
        @Override public boolean execute(String sql, int autoGeneratedKeys) { throw new UnsupportedOperationException(); }
        @Override public boolean execute(String sql, int[] columnIndexes) { throw new UnsupportedOperationException(); }
        @Override public boolean execute(String sql, String[] columnNames) { throw new UnsupportedOperationException(); }
        @Override public int getResultSetHoldability() { throw new UnsupportedOperationException(); }
        @Override public boolean isClosed() { throw new UnsupportedOperationException(); }
        @Override public void setPoolable(boolean poolable) { throw new UnsupportedOperationException(); }
        @Override public boolean isPoolable() { throw new UnsupportedOperationException(); }
        @Override public void closeOnCompletion() { throw new UnsupportedOperationException(); }
        @Override public boolean isCloseOnCompletion() { throw new UnsupportedOperationException(); }
        @Override public <T> T unwrap(Class<T> iface) { throw new UnsupportedOperationException(); }
        @Override public boolean isWrapperFor(Class<?> iface) { throw new UnsupportedOperationException(); }

        // Many JDBC methods omitted for brevity; add implementations if your PROD code uses them.
    }
}
